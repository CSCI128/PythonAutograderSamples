"""
test_public_function.py

This file contains the tests for the two required functions that students have to write,
`handle_shipment` and `handle_sale`.

The biggest difference with function tests vs main tests is that the runner is different,
and thus the `assertStdIo` is slightly different as well.

For the purposes of this demo, I am only doing public tests as most of the
private cases that will be *useful* have already been covered
"""

from gradescope_utils.autograder_utils.decorators import weight, number
from StudentSubmission import StudentSubmissionExecutor
# We use the function runner rather than main runner
# Internally this runner runs the entire student submission then uses reflection to
#  call the student's function.
from StudentSubmission.Runners import FunctionRunner
from TestingFramework import BaseTest
from StudentSubmission.common import PossibleResults


class TestPublicFunction(BaseTest):
    def setUp(self):
        self.environment = StudentSubmissionExecutor.generateNewExecutionEnvironment(self.studentSubmission)
        self.environment.timeout = 1

        # we don't declare the functional runner in this common setup method because it has to be tailored
        #  for each test case (as you'll see in a moment)

    def tearDown(self):
        StudentSubmissionExecutor.cleanup(self.environment)

    def assertStdIo(self, runner: FunctionRunner, expectedOutput: list[str]):
        # We still need the assertStdio here because we will be running assertions on the stdio generated by the
        #  functions.
        # We need to pass a runner in here as each test case will be creating a runner.
        # We don't want to do it at the class level in the setUp function as that implies that it is the same
        #  across runs when it should be different.
        # We are not passing the stdin into the environment as the runner gets run with the parameters that
        #  are needed for test.
        #  However, it works in the exact same way that it works for the regular stdio

        StudentSubmissionExecutor.execute(self.environment, runner)

        # We still get the output in the same way here
        # Remember, stdout is returned as a list
        actualOutput = StudentSubmissionExecutor.getOrAssert(self.environment, PossibleResults.STDOUT)

        # We don't need to do a 'assertCorrectNumberOfOutputLines' as we are testing smaller things that should
        #  only have one output line
        self.assertEqual(expectedOutput, actualOutput)

    @number(4.1)
    @weight(1)
    def test_handle_shipment(self):
        """Handle shipment with empty inventory"""

        # Parameters are passed in after the function name.
        # The function name *must* match the name of the function in the student's submission *exactly*
        # Internally; the FunctionRunner is using reflection to call the student's function.
        # This might be expanded in the future to use the builder pattern, but for now everything to call must be passed
        #  in the constructor,
        # It is also important to note that even though we are passing a dictionary in,
        #  we will not be able to assert its contents.
        #  This is because it is populated in a separate process, and that data is not
        #  shared back to the parent process, and is thus unable to be updated / asserted on.
        #  This is a known limitation of the way that the autograder is implemented, however, it is not
        #  really worth the time investment to share complex objects back to the parent

        runner = FunctionRunner("handle_shipment", {}, "apples", 100)
        expectedOutput = ["Received shipment of 100 apples"]

        self.assertStdIo(runner, expectedOutput)

    @number(4.2)
    @weight(1)
    def test_handle_sale(self):
        """Handle a sale with inventory"""

        # we can pass the inventory dictionary as a variable or declare it inline like the previous example
        inventory = {
            'apples': 10,
            'bananas': 10
        }

        runner = FunctionRunner("handle_sale", inventory, "apples", 1)
        expectedOutput = ["Sold 1 apples"]

        self.assertStdIo(runner, expectedOutput)

    @number(4.3)
    @weight(1)
    def test_handle_sale_no_inventory(self):
        """Handle a sale when item is not in inventory"""

        runner = FunctionRunner("handle_sale", {}, "apples", 1)

        expectedOutput = ["ERROR: apples not found in inventory"]

        self.assertStdIo(runner, expectedOutput)

    @number(4.4)
    @weight(1)
    def test_handle_sale_limited_inventory(self):
        """Handle a sale with limited inventory"""

        inventory = {
            'apples': 10
        }
        runner = FunctionRunner("handle_sale", inventory, "apples", 11)

        expectedOutput = ["Sold 10 apples"]

        self.assertStdIo(runner, expectedOutput)
